---
eleventyNavigation:
  key: Research
  order: 3
layout: simple.njk
stylesheets:
  - "/styles/pages/research.css"
title: Research
description: Cutting-edge AI research projects and academic contributions
---

# Research

Advanced research projects exploring the frontiers of AI, machine learning, and software engineering. These projects contribute to academic understanding and push the boundaries of what's possible with intelligent systems.

<!-- Research Logos -->
<div class="project-brochure" id="logos-research">
  <div class="project-visual">
    <h1>LOGOS</h1>
  </div>
  <div class="project-content">
    <h3>Bayesian Symbolic Reasoning for Agents That Can Explain Themselves</h3>
    <div class="project-pitch">
      <p><strong>Reasoning you can actually trust.</strong></p>
      <p>Neural approaches are black boxes. Symbolic systems ignore uncertainty. Logos combines grammar-constrained S-expression decoding with Bayesian inference—agents reason in provably valid logic while quantifying what they don't know.</p>
      <div class="project-features">
        <div class="feature-item">
          <strong>Explainable by Design:</strong> Every reasoning step follows valid S-expression syntax. No more "the model said so"—you can trace exactly how conclusions were reached.
        </div>
        <div class="feature-item">
          <strong>Uncertainty Built In:</strong> Bayesian budget optimization tracks confidence across time, computation, and cost. Agents know when to gather more information vs. act on what they have.
        </div>
        <div class="feature-item">
          <strong>Mathematically Rigorous:</strong> Blackwell dominance validation ensures every epistemic action improves beliefs. Zero tolerance for reasoning that destroys information.
        </div>
      </div>
      <p>Bridging symbolic reasoning and probabilistic inference for agent intelligence you can audit, explain, and trust.</p>
      <div class="project-cta">
        <a href="https://github.com/sibyllinesoft/logos" target="_blank" rel="noopener noreferrer" class="btn-unified btn-primary">
          <span class="btn-inner">
            View on GitHub
            <i data-lucide="github"></i>
          </span>
        </a>
      </div>
    </div>
  </div>
</div>

<!-- Research Lethe -->
<div class="project-brochure" id="lethe-research">
  <div class="project-visual">
    <h1>LETHE</h1>
  </div>
  <div class="project-content">
    <h3>Infinite Context Through Intelligent Forgetting</h3>
    <div class="project-pitch">
      <p><strong>Stop managing context manually.</strong></p>
      <p>Token limits kill productivity. You waste time choosing what to include, agents forget critical details, and conversations die after 50 messages. Lethe reads everything but forgets what doesn't matter—automatically.</p>
      <div class="project-features">
        <div class="feature-item">
          <strong>Intelligent Filtering:</strong> Relevance algorithms identify and compress irrelevant messages while preserving every detail that matters. No manual curation required.
        </div>
        <div class="feature-item">
          <strong>Information-Dense Rewriting:</strong> Verbose conversations compress into tight summaries that maintain full semantic fidelity. Same meaning, fraction of the tokens.
        </div>
        <div class="feature-item">
          <strong>Sessions That Don't Die:</strong> Conversations stretch to 300+ messages without drift or performance loss. Sub-3s response times at any context length.
        </div>
      </div>
      <p>Recover 90% of time spent on context management. Let agents access unlimited history while you focus on the actual work.</p>
    </div>
  </div>
</div>

<!-- Research ScrambleBench -->
<div class="project-brochure" id="scramblebench-research">
  <div class="project-visual">
    <h1>SCRAMBLEBENCH</h1>
  </div>
  <div class="project-content">
    <h3>Know What Your Models Actually Understand</h3>
    <div class="project-pitch">
      <p><strong>Benchmarks lie when models memorize.</strong></p>
      <p>Training data contamination makes evaluation meaningless. Models ace tests they've seen, giving you false confidence in capabilities. ScrambleBench creates genuinely novel test cases—same logic, zero memorization advantage.</p>
      <div class="project-features">
        <div class="feature-item">
          <strong>Constructed Language Translation:</strong> Transform benchmarks into artificial languages that preserve logical structure. Test reasoning, not recall.
        </div>
        <div class="feature-item">
          <strong>Document Transformation:</strong> Advanced restructuring maintains semantic meaning while creating content no model has seen. Real evaluation at last.
        </div>
        <div class="feature-item">
          <strong>100+ Model Testing:</strong> OpenRouter integration with comprehensive statistical analysis. Compare capabilities across the entire model landscape.
        </div>
      </div>
      <p>Stop guessing whether your model understands or memorized. Get evaluation results you can actually trust.</p>
      <div class="project-cta">
        <a href="https://sibylline.dev/scramblebench/" target="_blank" rel="noopener noreferrer" class="btn-unified btn-primary">
          <span class="btn-inner">
            Documentation
            <i data-lucide="book-open"></i>
          </span>
        </a>
        <a href="https://github.com/sibyllinesoft/scramblebench" target="_blank" rel="noopener noreferrer" class="btn-unified btn-primary">
          <span class="btn-inner">
            View on GitHub
            <i data-lucide="github"></i>
          </span>
        </a>
      </div>
    </div>
  </div>
</div>

<!-- Research FastPath -->
<div class="project-brochure" id="fastpath-research">
  <div class="project-visual">
    <h1>FASTPATH</h1>
  </div>
  <div class="project-content">
    <h3>Give LLMs the Code That Actually Matters</h3>
    <div class="project-pitch">
      <p><strong>Most context selection is random guessing.</strong></p>
      <p>Naive concatenation and basic similarity metrics miss what's actually important in codebases. FastPath applies PageRank to code dependency graphs—identifying central components that maximize understanding per token.</p>
      <div class="project-features">
        <div class="feature-item">
          <strong>PageRank for Code:</strong> Graph algorithms identify the most connected, most important components. 27.8% improvement in QA accuracy over BM25 and TF-IDF baselines (p&lt;0.001).
        </div>
        <div class="feature-item">
          <strong>Optimal Information Density:</strong> Multi-fidelity architecture allocates token budget across semantic chunks, dependencies, and docs. Maximum insight per token.
        </div>
        <div class="feature-item">
          <strong>Production-Ready Performance:</strong> 4.7× speedup and 75% memory reduction. Reproducible benchmarks designed for academic publication standards.
        </div>
      </div>
      <p>The first PageRank approach to intelligent code selection. Give your LLMs context that makes them smarter, not just longer.</p>
      <div class="project-cta">
        <a href="https://github.com/sibyllinesoft/scribe/blob/main/paper/draft.pdf" target="_blank" rel="noopener noreferrer" class="btn-unified btn-primary">
          <span class="btn-inner">
            Research Paper
            <i data-lucide="file-text"></i>
          </span>
        </a>
      </div>
    </div>
  </div>
</div>

<!-- Research Matrix -->
<div class="project-brochure" id="matrix-research">
  <div class="project-visual">
    <h1>MATRIX</h1>
  </div>
  <div class="project-content">
    <h3>A Wind Tunnel for AI Coding Agents</h3>
    <div class="project-pitch">
      <p><strong>Static benchmarks don't reflect reality.</strong></p>
      <p>How do you systematically evaluate AI coding agents when every codebase is different? Matrix generates synthetic repositories with controllable complexity—a wind tunnel where you test agents under precise, reproducible conditions.</p>
      <div class="project-features">
        <div class="feature-item">
          <strong>Dial-a-Complexity:</strong> Generate codebases with precise control over lines of code, dependency depth, and coupling. Test how agents perform as complexity scales.
        </div>
        <div class="feature-item">
          <strong>Realistic Bug Injection:</strong> Off-by-one errors, API misuse, null handling issues—systematic injection of bugs that mirror real development challenges.
        </div>
        <div class="feature-item">
          <strong>Full Instrumentation:</strong> Behavior tracing captures every agent decision. Understand not just what agents do, but why they fail.
        </div>
      </div>
      <p>Creating the scientific foundation for rigorous AI coding agent evaluation. Finally measure what actually matters.</p>
    </div>
  </div>
</div>

<!-- Research Modules -->
<div class="project-brochure" id="modules-research">
  <div class="project-visual">
    <h1>BEM</h1>
  </div>
  <div class="project-content">
    <h3>Dynamic Expert Modules That Adapt to Any Task</h3>
    <div class="project-pitch">
      <p><strong>LoRA is static. Reality isn't.</strong></p>
      <p>Traditional fine-tuning methods can't handle distribution shifts or varying task complexity. BEM introduces dynamic expert routing—context-specific weight modifications that adapt in real-time to what your model actually needs.</p>
      <div class="project-features">
        <div class="feature-item">
          <strong>Context-Aware Routing:</strong> Dynamic weight modification specializes computational pathways based on input characteristics. Different tasks get different experts automatically.
        </div>
        <div class="feature-item">
          <strong>Cross-Modal Performance:</strong> Unified architecture handles text, vision, and multimodal tasks. One system, consistent results across domains.
        </div>
        <div class="feature-item">
          <strong>Proven Results:</strong> 12-42% better accuracy than 6 major MoE-LoRA competitors. Maintains performance across distribution shifts and adversarial inputs.
        </div>
      </div>
      <p>Dynamic neural architectures that achieve superior adaptation with cross-domain robustness. Fine-tuning that actually keeps up with your use cases.</p>
      <div class="project-cta">
        <a href="https://github.com/sibyllinesoft/BEM/" target="_blank" rel="noopener noreferrer" class="btn-unified btn-primary">
          <span class="btn-inner">
            View on GitHub
            <i data-lucide="github"></i>
          </span>
        </a>
        <a href="https://github.com/sibyllinesoft/BEM/blob/master/archive/paper/paper.pdf" target="_blank" rel="noopener noreferrer" class="btn-unified btn-primary">
          <span class="btn-inner">
            Research Paper
            <i data-lucide="file-text"></i>
          </span>
        </a>
      </div>
    </div>
  </div>
</div>

<!-- Research Arachne -->
<div class="project-brochure" id="arachne-research">
  <div class="project-visual">
    <h1>ARACHNE</h1>
  </div>
  <div class="project-content">
    <h3>Crack Obfuscation That Defeats Everything Else</h3>
    <div class="project-pitch">
      <p><strong>Pattern matching doesn't work on modern obfuscation.</strong></p>
      <p>Sophisticated JavaScript obfuscation defeats traditional tools. Arachne uses formal methods—IR analysis, Z3 constraint solving, and bytecode lifting—to achieve 95% success where competitors manage 45-70%.</p>
      <div class="project-features">
        <div class="feature-item">
          <strong>True Semantic Understanding:</strong> Multi-pass IR analysis with CFG and SSA form. The only tool that actually understands what obfuscated code does, not just what it looks like.
        </div>
        <div class="feature-item">
          <strong>Z3 Constraint Solving:</strong> SMT solver integration cracks mathematical obfuscation and constraint-based hiding that defeats every other tool.
        </div>
        <div class="feature-item">
          <strong>Bytecode Lifting:</strong> QuickJS and V8 bytecode analysis handles VM-based protection schemes. The only deobfuscator that works at the bytecode level.
        </div>
      </div>
      <p>Formal methods meet practical JavaScript deobfuscation. Zero false positives with proven semantic preservation.</p>
      <div class="project-cta">
        <a href="https://github.com/sibyllinesoft/arachne" target="_blank" rel="noopener noreferrer" class="btn-unified btn-primary">
          <span class="btn-inner">
            View on GitHub
            <i data-lucide="github"></i>
          </span>
        </a>
      </div>
    </div>
  </div>
</div>
